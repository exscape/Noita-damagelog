dofile_once("mods/damagelog/files/utils.lua")
dofile_once("mods/damagelog/files/list.lua")

-- Generated by a helper mod (damagelog-dev-helper)
local additional_entities = dofile_once("mods/damagelog/files/additional_entities.lua")

local damage_data = List.new() -- All damage that has not yet been received and parsed by the GUI code
local next_hit_id = 1          -- The ID that will be used for the next hit (i.e. no hit with this ID exists yet)
local damage_from_material_prefix = nil

local function get_entity_name(entity_id)
    -- Yes, this is hacky, but it probably beats having a single English word among the entities
    local unknown = "$menuoptions_configurecontrols_keyname_unknown"
    if entity_id == 0 then
        return unknown
    end

    local entity_raw_name = EntityGetName(entity_id)
    if entity_raw_name == nil or #entity_raw_name <= 0 then
        -- Thus unfortunately happens for some entities, like animals/rainforest/bloom.xml, that use a base entity.
        -- The name is not inherited from the base entity file, so it's left with "" as a name.
        -- Try to look it up in our precomputed lookup table, which contains all such names as of the mod's release.

        local filename = EntityGetFilename(entity_id)
        if filename and #filename > 0 then
            -- if statement is probably useless, but eh
            return additional_entities[filename] or unknown
        else
            return unknown
        end
    -- Handle a few special cases
    elseif entity_raw_name == "DEBUG_NAME:player" then
        return "$animal_player"
    elseif entity_raw_name == "workshop_altar" then
        return "$biome_holymountain"
    else
        return entity_raw_name
    end
end

local function get_player_entity()
    local players = EntityGetWithTag("player_unit")
    if #players == 0 then
        return nil
    end

    return players[1]
end

local function get_player_health()
    local player = get_player_entity()
    if player == nil then
        return 0, 0
    end

    local damagemodels = EntityGetComponent(player, "DamageModelComponent")
    if damagemodels == nil or #damagemodels < 1 then
        return 0, 0
    end

    return tonumber(ComponentGetValue2(damagemodels[1], "hp")) * 25,
           tonumber(ComponentGetValue2(damagemodels[1], "max_hp")) * 25
end

local function source_and_type_from_entity_and_message(entity_thats_responsible, message)
    -- Ugh. The message argument is ALMOST always nice (e.g. "$damage_fire"), but AFAIK there is
    -- EXACTLY one other case: damage from materials, such as lava, which uses $damage_frommaterial.
    -- This will cause message to look like this:
    -- "damage from material: Lava"
    -- or, if you play in German:
    -- "Schaden durch Substanz: Lava"
    -- In other words, the message changes depending on the language, rather than using
    -- the untranslated string as in every other case.
    -- This seems to work fine in every latin language, and Russian; the others can't be displayed by
    -- Dear ImGui with the fonts we have anyway, so there's not a lot I can do for the other languages.
    local orig_message = message

    if damage_from_material_prefix == nil then
        damage_from_material_prefix = GameTextGet("$damage_frommaterial") or "damage from material: $0"
        damage_from_material_prefix = (damage_from_material_prefix:gsub("$0", ""))
    end

    local damage_was_from_material = message:find(damage_from_material_prefix)
    message = (message:gsub(damage_from_material_prefix, ""))
    -- This is typically a $ string, but not always. If not, the first letter should be uppercased.
    local damage_type = initialupper(message)

    if entity_thats_responsible ~= 0 then
        -- Show the responsible entity if one exists
        local entity_name = get_entity_name(entity_thats_responsible)

        -- This is terribly ugly, but I'm not sure there's a better way.
        -- For whatever reason, Noita now returns $biome_holymountain as the entity
        -- that causes "cursed area" damage (e.g. when digging towards a PW).
        if entity_name == '$biome_holymountain' and orig_message == '$damage_rock_curse' then
            return orig_message, orig_message, damage_was_from_material
        end

        return entity_name, damage_type, damage_was_from_material
    elseif message:sub(1,1) == "$" or damage_was_from_material then
        -- No responsible entity; damage is something like toxic sludge, fire etc.
        -- Show that as the source and type.
        -- I don't at all like the hack here, but the only other option I've found is to always use
        -- the "lower accuracy" mode and have the time display go from "now" to 3s for every damage type.
        -- I'm not sure about that, most damage is "one-shot" damage and we should be able to show the proper
        -- time for those.
        return damage_type,
        damage_type,
        damage_was_from_material or damage_type == "$damage_radioactive" or damage_type == "$damage_poison"
    else
        -- Should never happen; displayed for debugging purposes so that the mod can be updated
        log("damagelog WARNING: unknown message: " .. tostring(message))
        return message, damage_type, damage_was_from_material
    end
end

local function should_always_pool(source, type)
    local additional_poolable_types = { ["$damage_healing"] = 1, ["$damage_plasmabeam"] = 1, ["$damage_orb_blood"] = 1}
    -- The first check might need some explaining.
    -- Noita sends "damage from material: XYZ" as message for e.g. lava, poison droplets (not poison STAINS)
    -- and other things. We probably want to pool all of them, but even if we didn't,
    -- there's no good solution. We would need to check for the string "fire" in every language, then
    -- "acid" in every language, and so on, since Noita translates them prematurely.
    -- The second is more straightforward: if the SOURCE is a $damage string, it's from a stain or similar.
    return type:sub(1,1) ~= '$' or source:sub(1,8) == "$damage_" or additional_poolable_types[type]
end

-- Called by Noita every time the player takes damage
-- Hook is initialized in init.lua
function damage_received(damage, message, entity_thats_responsible, is_fatal, projectile_thats_responsible)
    if next_hit_id == 1 then
        -- The value starts at 1. Check if this is a continuation of a previous run (i.e. the player recently
        -- loaded, and this is the first damage) so that we don't restart the ID counter and end up with duplicates.
        next_hit_id = tonumber(GlobalsGetValue("damagelog_highest_id_written", "0")) + 1
    end

    local source, damage_type, lower_time_accuracy = source_and_type_from_entity_and_message(entity_thats_responsible, message)
    damage = damage * 25 -- TODO: use magic number? (GUI_HP_MULTIPLIER)

    local hp, max_hp = get_player_health()
    local hp_after = clamp(hp - damage, 0, max_hp)
    max_hp = clamp(math.floor(max_hp), 1, max_hp) -- Noita seems to floor prior to displaying it

    if hp_after <= 0 then
        hp_after = 0
    elseif hp_after < 1 then
        hp_after = 1
    else
        -- The game GUI seems to do this; our display can show 1 hp extra without flooring first
        hp_after = math.floor(hp_after)
    end

    local current_biome = BiomeMapGetName() -- Uses the camera position vs the player transform as it's faster
    if current_biome:sub(1, 1) ~= '$' then
        current_biome = " "
    end

    -- Clean up old entries from damage_data; i.e. entries that have already been received by the GUI code
    local highest_read = tonumber(GlobalsGetValue("damagelog_highest_id_read", "0"))
    while not List.isempty(damage_data)
          and List.peekleft(damage_data).id <= highest_read do
        List.popleft(damage_data)
    end

    -- Store the data in the list and send it to the GUI
    List.pushright(damage_data, {
        source = source,
        type = damage_type,
        lower_time_accuracy = lower_time_accuracy,
        damage = damage,
        hp = hp_after,
        max_hp = max_hp,
        time = GameGetRealWorldTimeSinceStarted(),
        frame = GameGetFrameNum(),
        always_pool = should_always_pool(source, damage_type), -- true if this is a damage type that repeats quickly, like fire/toxic sludge/poison
        location = current_biome,
        id = next_hit_id,
    })

    store_damage_data(damage_data, next_hit_id)
    next_hit_id = next_hit_id + 1
end